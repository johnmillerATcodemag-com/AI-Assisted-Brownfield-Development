#!/usr/bin/env python3
"""
GitHub Issue Creator for Security Findings
Creates GitHub issues from security scan results
"""

import json
import os
from datetime import datetime

from github import Github


def create_issue_from_finding(repo, finding):
    """Create a GitHub issue from a security finding"""
    severity = finding.get('severity', 'MEDIUM').upper()
    rule_name = finding.get('rule', 'security-issue')
    file_path = finding.get('file', 'unknown')
    line_number = finding.get('line', 0)
    description = finding.get('description', 'Security vulnerability detected')
    cwe = finding.get('cwe', 'CWE-000')
    context = finding.get('context', finding.get('match', 'Code snippet not available'))

    # Create issue title
    title = f"[SECURITY] [{severity}] {description} - {os.path.basename(file_path)}"

    # Map severity to priority emoji
    priority_map = {
        'CRITICAL': '🔴 Critical',
        'HIGH': '🟠 High',
        'MEDIUM': '🟡 Medium',
        'LOW': '🟢 Low'
    }
    priority = priority_map.get(severity, '🟡 Medium')

    # Create detailed issue body
    body = f"""## 🔒 Security Vulnerability Report

### Vulnerability Summary
**Severity**: {priority}
**CWE ID**: {cwe}
**Component**: `{file_path}` (Line {line_number})
**Detection Rule**: {rule_name}

### Description
{description}

### Impact Assessment
**Business Impact**:
- Potential security vulnerability that could be exploited by attackers
- May lead to data exposure, system compromise, or service disruption
- Could impact user trust and regulatory compliance

**Technical Impact**:
- Security control bypass potential
- Data integrity concerns
- System availability risk

### Location and Context
**File**: `{file_path}`
**Line**: {line_number}

```
{context}
```

### Remediation Steps

#### Immediate Actions (Priority 1)
- [ ] Review the identified code section for security implications
- [ ] Implement input validation and sanitization if applicable
- [ ] Apply principle of least privilege
- [ ] Add security controls as appropriate

#### Short-term Fixes (1-2 weeks)
- [ ] Refactor code to follow secure coding practices
- [ ] Add automated security tests
- [ ] Update security documentation
- [ ] Conduct code review with security focus

#### Long-term Improvements (1-3 months)
- [ ] Implement security scanning in CI/CD pipeline
- [ ] Add security training for development team
- [ ] Regular security audits and assessments
- [ ] Update security policies and procedures

### Testing Recommendations
- [ ] Unit tests for security controls
- [ ] Integration tests for authentication/authorization
- [ ] Penetration testing validation
- [ ] Automated security scanning

### References
- [OWASP Top 10](https://owasp.org/Top10/)
- [CWE Details: {cwe}](https://cwe.mitre.org/data/definitions/{cwe.split('-')[1] if '-' in cwe else '000'}.html)
- [Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)

**Generated by**: GitHub Actions Security Analysis
**Date**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}
**Commit**: {os.environ.get('GITHUB_SHA', 'unknown')}
"""

    # Create appropriate labels
    labels = ['security', 'vulnerability', severity.lower()]
    if 'injection' in rule_name.lower():
        labels.append('injection')
    if 'xss' in rule_name.lower():
        labels.append('xss')
    if 'crypto' in rule_name.lower():
        labels.append('cryptography')
    if 'auth' in rule_name.lower():
        labels.append('authentication')

    try:
        # Check if similar issue already exists
        existing_issues = repo.get_issues(state='open', labels=['security'])

        # Simple duplicate check based on file and rule
        for issue in list(existing_issues)[:10]:  # Check last 10 security issues
            if file_path in issue.body and rule_name in issue.body:
                print(f"Similar issue already exists: {issue.html_url}")
                return None

        # Create the issue
        issue = repo.create_issue(
            title=title,
            body=body,
            labels=labels
        )

        print(f"Created security issue #{issue.number}: {title}")
        return {
            'number': issue.number,
            'title': title,
            'severity': severity,
            'url': issue.html_url
        }

    except Exception as e:
        print(f"Error creating issue for {rule_name}: {e}")
        return None

def process_custom_results(repo):
    """Process custom security scan results"""
    created_issues = []

    if os.path.exists('custom-security-results.json'):
        with open('custom-security-results.json', 'r') as f:
            data = json.load(f)

        findings = data.get('findings', [])
        print(f"Processing {len(findings)} custom security findings...")

        for finding in findings:
            issue_info = create_issue_from_finding(repo, finding)
            if issue_info:
                created_issues.append(issue_info)

    return created_issues

def process_semgrep_results(repo):
    """Process Semgrep scan results"""
    created_issues = []

    if os.path.exists('semgrep-results.json'):
        with open('semgrep-results.json', 'r') as f:
            data = json.load(f)

        results = data.get('results', [])
        print(f"Processing {len(results)} Semgrep findings...")

        for result in results:
            finding = {
                'file': result.get('path', ''),
                'line': result.get('start', {}).get('line', 0),
                'rule': result.get('check_id', 'semgrep-rule'),
                'severity': result.get('extra', {}).get('severity', 'MEDIUM').upper(),
                'description': result.get('extra', {}).get('message', 'Semgrep security finding'),
                'match': result.get('extra', {}).get('lines', ''),
                'cwe': 'CWE-000'  # Semgrep doesn't always provide CWE
            }

            issue_info = create_issue_from_finding(repo, finding)
            if issue_info:
                created_issues.append(issue_info)

    return created_issues

def create_security_summary(repo, all_issues):
    """Create a summary comment if this is a PR"""
    if not all_issues:
        return

    summary = f"""## 🔒 Security Analysis Summary

The automated security analysis has completed and found {len(all_issues)} security issues that require attention.

### Issues Created:
"""

    for issue in all_issues:
        priority_emoji = {
            'CRITICAL': '🔴',
            'HIGH': '🟠',
            'MEDIUM': '🟡',
            'LOW': '🟢'
        }.get(issue['severity'], '🟡')

        summary += f"- {priority_emoji} [#{issue['number']} {issue['title']}]({issue['url']})\n"

    summary += f"""
### Next Steps:
1. **Review Critical and High severity issues first**
2. **Assign issues to appropriate team members**
3. **Plan remediation in upcoming sprints**
4. **Update security documentation as needed**

**Analysis Date**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}
**Commit**: {os.environ.get('GITHUB_SHA', 'unknown')[:8]}
"""

    # Try to comment on the PR if this is a PR event
    if os.environ.get('GITHUB_EVENT_NAME') == 'pull_request':
        try:
            pr_number_str = os.environ.get('GITHUB_REF', '').split('/')[-2]
            if pr_number_str and pr_number_str.isdigit():
                pr = repo.get_pull(int(pr_number_str))
                pr.create_issue_comment(summary)
                print(f"Added security summary comment to PR #{pr_number_str}")
        except Exception as e:
            print(f"Could not comment on PR: {e}")

def main():
    """Main execution function"""
    try:
        # Initialize GitHub connection
        github = Github(os.environ['GITHUB_TOKEN'])
        repo = github.get_repo(f"{os.environ['REPO_OWNER']}/{os.environ['REPO_NAME']}")

        print("Creating GitHub issues for security findings...")

        # Process different types of security results
        all_created_issues = []

        # Process custom security results
        custom_issues = process_custom_results(repo)
        all_created_issues.extend(custom_issues)

        # Process Semgrep results
        semgrep_issues = process_semgrep_results(repo)
        all_created_issues.extend(semgrep_issues)

        # Create summary comment if there are issues
        create_security_summary(repo, all_created_issues)

        if all_created_issues:
            print(f"Successfully created {len(all_created_issues)} security issues")

            # Write summary to file for other workflow steps
            with open('created-issues-summary.json', 'w') as f:
                json.dump({
                    'total_created': len(all_created_issues),
                    'issues': all_created_issues
                }, f, indent=2)
        else:
            print("No new security issues were created")

        return len(all_created_issues)

    except Exception as e:
        print(f"Error in issue creation: {e}")
        return -1

if __name__ == "__main__":
    exit_code = main()
    exit(0 if exit_code >= 0 else 1)
